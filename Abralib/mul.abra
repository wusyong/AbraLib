import AbraLib/types

import AbraLib/fulladd
import AbraLib/halfadd

mul [
  // todo: generate a lookup table of 729 products of all possible
  //       2 sets of 3-trit input values with 6-trit output values
  //       make sure that all values are least-significant-trit-first encoded
  -,-,-, -,-,- = -,1,-,0,1,-; // -13 * -13 = -169
  //... etcetera ...
  1,1,1, 1,1,1 = 1,-,1,0,-,1; // 13 * 13 = 169
];

mulTryte (lhs [Tryte], rhs [Tryte]) = mul[lhs[0], lhs[1], lhs[2], rhs[0], rhs[1], rhs[2]];

// this does elementary school type multiplication in the base of the next lower type
// so it essentially multiplies two 3-digit values where the digits are of that base which allows
// us to easily construct each next data type level in terms of the previous data type level.
// still WIP atm

// ABC * DEF
//        AD
//       AE0
//      AF00
//       BD0
//      BE00
//     BF000
//      CD00
//     CE000
//    CF0000  1
//-------------

// reorder a little by grouping same-level terms

// ABC * DEF
//        AD
//       AE0
//       BD0
//      AF00
//      BE00
//      CD00
//     BF000
//     CE000
//    CF0000  1
//-------------


// note that a mul() function will return double the width
// of its parameters so as not to lose any precision
template mulFunc<T, P> mul<T> (lhs [T], rhs [T]) = {
  // get lhs digits
  A = lhs[0 * P..];
  B = lhs[1 * P..];
  C = lhs[2 * P..];

  // get rhs digits
  D = rhs[0 * P..];
  E = rhs[1 * P..];
  F = rhs[2 * P..];

  // determine all products
  AD = mul<P>(A, D);
  AE = mul<P>(A, E);
  AF = mul<P>(A, F);
  BD = mul<P>(B, D);
  BE = mul<P>(B, E);
  BF = mul<P>(B, F);
  CD = mul<P>(C, D);
  CE = mul<P>(C, E);
  CF = mul<P>(C, F);

  // note: the sum of 2 products can never generate
  //      a carry, but the sum of 3 products can...

  // AD
  tryte0 [P] = AD[0 * P..];
  carry0 = AD[1 * P..];

  // AE0 + BD0 + carry0
  AEBD = addProduct<P>(AE, BD);
  AEBDc = addCarryToProduct<P>(AEBD[1..], carry0, 0);
  tryte1 [P] = AEBDc[0 * P..];
  carry1 = AEBDc[1 * P..];

  // AF00 + BE00 + CD00 + carry1
  AFBE = addProduct<P>(AF, BE);
  AFBEc = addCarryToProduct<P>(AFBE[1..], carry1, 0);
  // note: adding 3rd product, watch the extra overflow carry trit
  AFBEcCD = addProduct<P>(AFBEc, CD);
  tryte2 [P] = AFBEcCD[1 + 0 * P..];
  carry2 = AFBEcCD[1 + 1 * P..];

  // BF000 + CE000 + carry2
  BFCD = addProduct<P>(BF, CE);
  // note: this is where the extra overflow carry trit goes
  BFCDc = addCarryToProduct<P>(BFCD, carry2, AFBEcCD[0]);
  tryte3 [P] = BFCDc[0 * P..];
  carry3 = BFCDc[1 * P..];

  // CF0000 + carry3
  CFc = addCarryToProduct<P>(CF, carry3, 0);
  tryte4 [P] = CFc[0 * P..];
  tryte5 [P] = CFc[1 * P..];

  tryte0, tryte1, tryte2, tryte3, tryte4, tryte5;
};

mulFunc<Tiny, Tryte>;
mulFunc<Int, Tiny>;
mulFunc<Huge, Int>;
mulFunc<Hash, Huge>;


// add two products together
template addProductFunc<T> addProduct<T>(lhs [T * 2], rhs [T * 2]) = {
  lo = fullAdd<T>(lhs[0 * T..], rhs[0 * T..], 0);
  hi = fullAdd<T>(lhs[1 * T..], rhs[1 * T..], lo[0]);
  hi[0], lo[1..], hi[1..];
}

addProductFunc<Tryte>;
addProductFunc<Tiny>;
addProductFunc<Int>;
addProductFunc<Huge>;


// add carry and possible extra trit to a product
template addCarryToProductFunc<T> addCarryToProduct<T>(lhs [T * 2], carry [T], extraTrit [Trit]) = {
  lo = fullAdd<T>(lhs[0 * T..], carry, extraTrit);
  hi = halfAdd<T>(lhs[1 * T..], lo[0]);
  lo[1..], hi[1..];
}

addCarryToProductFunc<Tryte>;
addCarryToProductFunc<Tiny>;
addCarryToProductFunc<Int>;
addCarryToProductFunc<Huge>;
